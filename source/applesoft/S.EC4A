1010 *--------------------------------
1020 *      CONVERT STRING TO FP VALUE IN FAC
1030 *
1040 *      STRING POINTED TO BY TXTPTR
1050 *      FIRST CHAR ALREADY SCANNED BY CHRGET
1060 *      (A) = FIRST CHAR, C=0 IF DIGIT.
1070 *--------------------------------
1080 FIN    LDY #0       CLEAR WORKING AREA ($99...$A3)
1090        LDX #10   TMPEXP, EXPON, DPFLG, EXPSGN, FAC, SERLEN
1100 .1     STY TMPEXP,X
1110        DEX
1120        BPL .1
1130 *--------------------------------
1140        BCC FIN.2    FIRST CHAR IS A DIGIT
1150        CMP #'-'     CHECK FOR LEADING SIGN
1160        BNE .2       NOT MINUS
1170        STX SERLEN   MINUS, SET SERLEN = $FF FOR FLAG
1180        BEQ FIN.1    ...ALWAYS
1190 .2     CMP #'+'     MIGHT BE PLUS
1200        BNE FIN.3    NOT PLUS EITHER, CHECK DECIMAL POINT
1210 *--------------------------------
1220 FIN.1  JSR CHRGET   GET NEXT CHAR OF STRING
1230 *--------------------------------
1240 FIN.2  BCC FIN.9    INSERT THIS DIGIT
1250 *--------------------------------
1260 FIN.3  CMP #'.'     CHECK FOR DECIMAL POINT
1270        BEQ FIN.10   YES
1280        CMP #'E'     CHECK FOR EXPONENT PART
1290        BNE FIN.7    NO, END OF NUMBER
1300        JSR CHRGET   YES, START CONVERTING EXPONENT
1310        BCC FIN.5    EXPONENT DIGIT
1320        CMP #TOKEN.MINUS  NEGATIVE EXPONENT?
1330        BEQ .1            YES
1340        CMP #'-'          MIGHT NOT BE TOKENIZED YET
1350        BEQ .1            YES, IT IS NEGATIVE
1360        CMP #TOKEN.PLUS   OPTIONAL "+"
1370        BEQ FIN.4         YES
1380        CMP #'+'          MIGHT NOT BE TOKENIZED YET
1390        BEQ FIN.4         YES, FOUND "+"
1400        BNE FIN.6    ...ALWAYS, NUMBER COMPLETED
1410 .1     ROR EXPSGN   C=1, SET FLAG NEGATIVE
1420 *--------------------------------
1430 FIN.4  JSR CHRGET   GET NEXT DIGIT OF EXPONENT
1440 *--------------------------------
1450 FIN.5  BCC GETEXP   CHAR IS A DIGIT OF EXPONENT
1460 *--------------------------------
1470 FIN.6  BIT EXPSGN   END OF NUMBER, CHECK EXP SIGN
1480        BPL FIN.7    POSITIVE EXPONENT
1490        LDA #0       NEGATIVE EXPONENT
1500        SEC          MAKE 2'S COMPLEMENT OF EXPONENT
1510        SBC EXPON
1520        JMP FIN.8
1530 *--------------------------------
1540 *      FOUND A DECIMAL POINT
1550 *--------------------------------
1560 FIN.10 ROR DPFLG    C=1, SET DPFLG FOR DECIMAL POINT
1570        BIT DPFLG    CHECK IF PREVIOUS DEC. PT.
1580        BVC FIN.1    NO PREVIOUS DECIMAL POINT
1590 *      A SECOND DECIMAL POINT IS TAKEN AS A TERMINATOR
1600 *      TO THE NUMERIC STRING.
1610 *      "A=11..22" WILL GIVE A SYNTAX ERROR, BECAUSE
1620 *      IT IS TWO NUMBERS WITH NO OPERATOR BETWEEN.
1630 *      "PRINT 11..22" GIVES NO ERROR, BECAUSE IT IS
1640 *      JUST THE CONCATENATION OF TWO NUMBERS.
1650 *--------------------------------
1660 *      NUMBER TERMINATED, ADJUST EXPONENT NOW
1670 *--------------------------------
1680 FIN.7  LDA EXPON    E-VALUE
1690 FIN.8  SEC          MODIFY WITH COUNT OF DIGITS
1700        SBC TMPEXP        AFTER THE DECIMAL POINT
1710        STA EXPON    COMPLETE CURRENT EXPONENT
1720        BEQ .15      NO ADJUST NEEDED IF EXP=0
1730        BPL .14      EXP>0, MULTIPLY BY TEN
1740 .13    JSR DIV10    EXP&lt;0, DIVIDE BY TEN
1750        INC EXPON    UNTIL EXP=0
1760        BNE .13
1770        BEQ .15      ...ALWAYS, WE ARE FINISHED
1780 .14    JSR MUL10    EXP>0, MULTIPLY BKY TEN
1790        DEC EXPON    UNTIL EXP=0
1800        BNE .14
1810 .15    LDA SERLEN   IS WHOLE NUMBER NEGATIVE?
1820        BMI .16      YES
1830        RTS          NO, RETURN, WHOLE JOB DONE!
1840 .16    JMP NEGOP    NEGATIVE NUMBER, SO NEGATE FAC
1850 *--------------------------------
1860 *      ACCUMULATE A DIGIT INTO FAC
1870 *--------------------------------
1880 FIN.9  PHA          SAVE DIGIT
1890        BIT DPFLG    SEEN A DECIMAL POINT YET?
1900        BPL .1       NO, STILL IN INTEGER PART
1910        INC TMPEXP   YES, COUNT THE FRACTIONAL DIGIT
1920 .1     JSR MUL10    FAC = FAC * 10
1930        PLA          CURRENT DIGIT
1940        SEC          &lt;&lt;&lt;SHORTER HERE TO JUST "AND #$0F">>>
1950        SBC #'0'     &lt;&lt;&lt;TO CONVERT ASCII TO BINARY FORM>>>
1960        JSR ADDACC   ADD THE DIGIT
1970        JMP FIN.1    GO BACK FOR MORE
1980 *--------------------------------
1990 *      ADD (A) TO FAC
2000 *--------------------------------
2010 ADDACC PHA          SAVE ADDEND
2020        JSR COPY.FAC.TO.ARG.ROUNDED
2030        PLA          GET ADDEND AGAIN
2040        JSR FLOAT    CONVERT TO FP VALUE IN FAC
2050        LDA ARG.SIGN
2060        EOR FAC.SIGN
2070        STA SGNCPR
2080        LDX FAC      TO SIGNAL IF FAC=0
2090        JMP FADDT    PERFORM THE ADDITION
2100 *--------------------------------
2110 *      ACCUMULATE DIGIT OF EXPONENT
2120 *--------------------------------
2130 GETEXP LDA EXPON    CHECK CURRENT VALUE
2140        CMP #10      FOR MORE THAN 2 DIGITS
2150        BCC .1       NO, THIS IS 1ST OR 2ND DIGIT
2160        LDA #100     EXPONENT TOO BIG
2170        BIT EXPSGN   UNLESS IT IS NEGATIVE
2180        BMI .2       LARGE NEGATIVE EXPONENT MAKES FAC=0
2190        JMP OVERFLOW LARGE POSITIVE EXPONENT IS ERROR
2200 .1     ASL          EXPONENT TIMES 10
2210        ASL
2220        CLC
2230        ADC EXPON
2240        ASL
2250        CLC          &lt;&lt;&lt; ASL ALREADY DID THIS! >>>
2260        LDY #0       ADD THE NEW DIGIT
2270        ADC (TXTPTR),Y    BUT THIS IS IN ASCII,
2280        SEC               SO ADJUST BACK TO BINARY
2290        SBC #'0'
2300 .2     STA EXPON    NEW VALUE
2310        JMP FIN.4    BACK FOR MORE
2320 *--------------------------------
